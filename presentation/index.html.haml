%section#intro
  %h1 Magritte
  %p Building a ruby interpreter for the language
  .tagline
    %p Jeanine Adkisson, Johannes Westlund
    %p Programming Research Group, Tokyo Institute of Technology
    %p
      %code
        advisor: Hidehiko Masuhara

%section<
  %h1 Basic theory
  %h3 Interpreter
  %ul
    %li Given a set of source language instructions, directly execute them.
    %li Different from compilers which does a transformation from a source language to a target language.
    %li However, many things similar to compilers, only back end essentially different.

%section(data-transition="fade-in slide-out")
  %h1 Basic theory
  .vs>
    .box
      %h3 Notations
      .block
        %ul
          %li Intermediate representation (IR)
          %li Abstract syntax tree (AST)
          %li Domain Specific Language (DSL)
          %li Front end
          %li Back end
  .vs>
    .box
      %img(src="./images/Typical_Pipeline.png")
    .box
      %img(src="./images/AST_example.png")


%section
  %h1 Pipeline
  .vs4>
    %h3 Lexer
    %p ↓
  .vs4>
    %h3 Parser
    %p ↓
  .vs4>
    %h3 AST generation
    %p ↓
  .vs4>
    %h3 Intepretation

%section
  %h2 Example
  .vs>
    = code 'qsh' do
      :plain
        x = 5
        a = add $x 2

%section
  %h1 Lexer
  .vs>
    .box
      %ul
        %li Implemented in ruby
        %li No usage of a lexer generator
        %li Simple regex parsing of input string to tokens
        %li Token stores type, value and location
  .vs>
    = code 'ruby' do
      :plain
        if @scanner.eos?
          return token(:eof)
        elsif scan /[\n;]|(#[^\n]*)/
          skip_lines
          return token(:nl)
          .
          .
          .

%section(data-transition="fade-in slide-out")
  %h2 Looking at the example
  .vs>
    = code 'qsh' do
      :plain
        x = 5
        a = add $x 2
  = code 'ruby' do
    :plain
      token(:bare) token(:eq) token(:num) token(:nl) ...

%section
  %h1 Skeleton tree
  .vs>
    .box
      %h3 Reason
      %ul
        %li Used to explicitly indicate nesting
        %li Builds up a tree structure
        %li Makes the transition to AST easier
  .vs>
    = code 'qsh' do
      :plain
        (f ?x) = (
          y = add %x 5
          z = mul %x 7
          ...
        )

%section(data-transition="fade-in slide-out")
  %h1 Skeleton tree
  .vs>
    .box
      %h3 How we implement skeleton trees
      %ul
        %li Three types of nodes exists
        %li Item: A single instruction.
        %li Nested: A nesting indicated by either (, [ or { character.
        %li Token: A normal token.
  .vs>
    = code 'ruby' do
      :plain
        (Item:
          (Nested:
            ...
          )
          (Token :eq)
          (Nested:
            (Item: ...)
            (Item: ...)
            ...
          )
        )

%section(data-transition="fade-in slide-out")
  %h2 Looking at the example
  .vs>
    = code 'qsh' do
      :plain
        x = 5
        a = add $x 2
  = code 'ruby' do
    :plain
      (Item: token(:bare) token(:eq) token(:num)) (Item: ...

%section
  %h2 Abstract syntax tree parsing
  .box
    %ul
      %li A DSL was created to help convert the skeleton tree into an AST
      %li The DSL was used to match and extract items from the skeleton tree
  = code 'ruby' do
    :plain
      item.match(rsplit(~_, token(:pipe), ~_)) do |before, after|
          return AST::Pipe[parse_line(before), parse_command(after)]
      end

%section
  %h2 Looking at the example
  .vs>
    = code 'qsh' do
      :plain
        x = 5
        a = add $x 2
  = code 'ruby' do
    :plain
      AST::Group[AST::Assignemnt[...], AST::Assignment[...]]

%section
  %h1 Interpreting
  %ul
    %li First we set up the environment by loading the builtin functions and standard library.
    %li Then we recursively evaluate the AST and execute the instruction of each node.
    %li In the case of our example not much will happen.

%section
  %h2 Any questions so far?

%section
  %h2 How it feels to use the language

%section
  %h2 The intention behind the language
  .vs>
    .box
      %ul
        %li It should be able to replace bash
        %li In order for it to do that shell scripting must be possible
        %li My opinion:
        %ul
          %li It easily outpreforms bash in ease of use
          %li The only thing missing is shell integration
  .vs>
    .box
      %ul
        %li It should be easy to write large programs
        %li A sort of validation that it's a general purpose language
        %li My task:
        %ul
          %li Write a large program in the language

%section
  %h2 Implegenting RSA encryption
  .vs>
    .box
      %h3 Basic idea
      %ul
        %li Find a prime number consiting of b bits
        %li From it you can create two keys
        %li Give one key to the world
        %li Keep the other one secret
  .vs>
    .box
      %h3 What I've currently done
      %ul
        %li Made program to generate prime numbers
        %li Drawback:
        %ul
          %li Currently so slow that only primes with 10 bits can be generated in reasonable time

/ 
/   .vs>
/     %h4 Channels as values
/     = code 'qsh' do
/       :plain
/         channel = (make-channel)
/         reader < $channel
/         writer > $channel
/ 
/     .space
/ 
/     %h4 Simple Spawning
/     = code 'qsh' do
/       :plain
/         & some-function arg arg
/         & some-function >$out <$in
/         & foo | bar | baz
/     -#>
/ 
/ 
/   .vs>
/     %h4 Anonymous channels (pipes)
/     = code 'qsh' do
/       :plain
/         command-1 | command-2
/ 
/         # equivalent to
/ 
/         channel = (make-channel)
/ 
/         & command-1 > $channel
/         command-2 < $channel
/ 
/ -# vimmmm
/ -# >
/ 
/ %section
/   %h2 Concurrency: Concepts
/ 
/   %p
/     Channels are <strong>synchronous</strong>:
/   %ul
/     %li reader and writer must both be present to make a communication.
/     %li Writes will <strong>block</strong> until the channel is read.
/ 
/   .vs>
/     %h4 Block on read
/     = code 'qsh' do
/       :plain
/         (sleep 10; put 1) | get
/ 
/ 
/   .vs>
/     %h4 Block on write
/     = code 'qsh' do
/       :plain
/         put 1 | (sleep 10; get)
/ 
/   %h4.fragment This is different than bash!
/ 
/ %section
/   %h2 Concurrency: Interruption
/ 
/   %h3 What should the behavior of this code be?
/ 
/   .vs>
/     = code 'qsh' do
/       :plain
/         (count-forever ?n) = (
/           put $n
/           count-forever (incr $n)
/         )
/ 
/         (take 0) = ()
/         (take ?n) = (
/           put (get)
/           take (decr $n)
/         )
/ 
/         count-forever 0 | take 10
/ 
/   .replacement.vs>
/     .fragment.current-visible
/       = code 'qsh' do
/         :plain
/           => 0; => 1; => 2; => ...; => 9
/ 
/           # but what happens to the process
/           # running `count-forever`...?
/ 
/     .block.fragment
/       %h4 Naive Approach: Nothing!
/ 
/       %ul
/         %li
/           %span.code count-forever
/           tries to write 10 to the output, blocks
/         %li
/           %span.code take
/           returns after 9, never reads
/         %li
/           %span.code count-forever
/           gets garbage-collected later
/ 
/     .fragment.box
/       %h4 This works!
/       %p ...as long as there are no cleanup actions
/ 
/ %section(data-transition="slide-in fade-out")
/   %h2 Concurrency: Interruption
/ 
/   %h3 But what if there are cleanup actions?
/ 
/   .vs>
/     = code 'qsh' do
/       :plain
/         (file-lines ?fname) = (
/           file = (open-file $fname
/             %%! close-file $fname)
/           ...
/         )
/ 
/ 
/         file-lines /tmp/huge-file
/           | take 10
/ 
/   .vs.nfragment>
/     %h4
/       With the naive approach, the file will remain open until gc!
/ 
/     .space
/     %p.left Processes expect to be cleaned up when the processes they're communicating with hang up.
/ 
/     .space
/     %p.left They expect an <strong>interrupt</strong> signal of some kind.
/ 
/ %section(data-transition="fade-in slide-out")
/   %h2 Concurrency: Interruption
/ 
/   %h3 Idea: channel-closing semantics
/ 
/   .vs>
/     = code 'qsh' do
/       :plain
/         (file-lines ?fname) = (
/           file = (open-file $fname
/             %%! close-file $fname)
/           ...
/         )
/ 
/ 
/         file-lines /tmp/huge-file
/           | take 10
/ 
/   .vs>
/     %ul
/       %li.fragment
/         When
/         %span.code take 10
/         returns, it
/         %strong closes
/         the channel.
/ 
/       %li.fragment
/         The
/         %span.code file-lines
/         process is either blocked on the channel or tries to write later
/ 
/       %li.fragment
/         Either situation results in the
/         %span.code file-lines
/         process being
/         %strong< interrupted
/         , and having its cleanup actions run.
/ 
/       .space
/       %h4.fragment This is how it works in bash already!
/ 
/ %section
/   %h2 Concurrency: Interruption
/ 
/   %h3 Multiple Readers/Writers
/ 
/   .block
/     Since spawned processes inherit inputs and outputs,<br>
/     it will be common to have <strong>multiple readers and writers</strong><br>
/     interacting with a channel at the same time.
/ 
/   = code 'qsh' do
/     :plain
/       (drain) = (put (get); drain)
/ 
/       ; count-forever | (& drain; & drain; & drain) | take 10
/ 
/       => 1 0 3 2 5 4 7 6 9 8
/ 
/ %section
/   %h2 Concurrency: Interruption
/ 
/   %h3 Idea: Interrupt a process when it's probably blocked forever
/ 
/   %h4.fragment (Remember: we bind channels at process spawn time!)
/ 
/   %center.fragment
/     close a channel when:<br>
/     %strong.bigger.fragment
/       The last reader exits
/     %br/
/ 
/     .fragment
/       \~ or ~
/       %br/
/ 
/       %strong.bigger
/         The last writer exits
/ 
/ %section
/   %h2 Concurrency: Interruption
/ 
/   %h3 Idea: Interrupt a process when it's probably blocked forever
/ 
/   %center
/     interrupt a process when:<br>
/     %strong.bigger.fragment
/       a channel it is blocked on closes
/     %br/
/ 
/     .fragment
/       \~ or ~
/       %br/
/ 
/       %strong.bigger
/         it tries to interact with a closed channel
/       .fragment (why?)
/ 
/ %section
/   %h2 Concurrency: Interruption
/ 
/   %h3 Problem: Reopening
/ 
/   .vs>
/     %h4 What should this code do?
/ 
/     = code 'qsh' do
/       :plain
/         c = (make-channel)
/         & count-forever > $c
/         & take 10 < $c
/         put 10 > $c
/     .space
/ 
/     %p.fragment
/       This code contains a <strong>race condition</strong>.
/ 
/     -#>
/   .vs>
/     %div
/       %p.left.fragment
/         If <code>take 10</code> returns before <code>put 10</code> is executed,
/         the channel will <strong>close</strong>. Otherwise the number 10 will be
/         inserted into the first 10 elements.
/       .space
/       %p.left.fragment
/         If we allow <code>$c</code> to be <strong>reopened</strong>, then
/         there is a worse race condition: if the channel closes before the final
/         <code>put</code>, we will remain blocked forever on the channel.
/ 
/   %h4.fragment
/     Therefore: Channel closing is permanent - further interactions will interrupt


/%section
/  %h2 Concurrency: Interruption
/
/  %h3 Problem: Closing Semantics = No Dynamic Channels
/
/  %h4 We can no longer write to a channel and leave it open!
/
/  .block
/    = code 'qsh' do
/      :plain
/        (make-broadcaster) = (
/          outputs = []
/
/          put {
/            (subscribe ?ch) = (%outputs = [...%outputs %ch])
/            (publish ?msg) = (for %outputs | each (%ch => put %msg > %ch))
/          }
/        )
/
/  %h4.fragment We can't keep a dynamic list of channels open continuously for writing.

/ %section
/   %h2 Concurrency: Interruption
/ 
/   %h3 Possible Solutions
/ 
/   .block
/     .vs>
/       %h4 Multiple writers to stdout (<span class="code">&amp;1</span>)
/       = code 'qsh' do
/         :plain
/           (subscribe >?c) = (
/             %channels = [...%channels %c]
/ 
/             # never return!
/             # keep stdout open!
/             sleep-forever
/           )
/ 
/           # usage
/           $bc!subscribe > $somewhere
/ 
/     .vs.fragment>
/       %h4 This is how UNIX FIFOs work!
/       %h4 (except they have a fixed buffer)
/       = code 'console' do
/         :plain
/           ~$ echo 'demo time!'
/           demo time!
/           ~$ 
/ %section
/   %h2 Magritte
/ 
/   %h4 Example 1
/ 
/   = code 'ruby' do
/     :plain
/       # (put 1; put 2) | add (get) (get) | mul 2 (get)
/       code do
/         s { put 1; put 2 }.p { put(get + get) }.p { put(get * 2) }.call
/ 
/         put 10
/       end
/ 
/       assert { output == [6, 10] }
/ 
/ %section
/   %h2 Magritte
/ 
/   %h4 Example 2
/ 
/   = code 'ruby' do
/     :plain
/       code do
/         s { for_ (0...30) }.p {
/           s { drain }.go
/           s { drain }.go
/           s { drain }.go
/         }.p { take 30 }.call
/       end
/ 
/       assert { output.sort == (0...30).to_a }
/ 
/ %section
/   %h2 Magritte
/ 
/   %h4 Example 3
/ 
/   .vs>
/     = code 'ruby' do
/       :plain
/         def put(val)
/           Proc.current.stdout.write(val)
/         end
/ 
/         def get
/           Proc.current.stdin.read
/         end
/ 
/   .vs>
/     = code 'ruby' do
/       :plain
/         def map(&f)
/           loop do
/             put (f.call(get))
/           end
/         end
/ 
/         def take(n)
/           n.times { put(get) }
/         end
/ 
/ %section
/   %h2 Magritte: Channels
/ 
/   = code 'ruby' do
/     :plain
/       class Channel
/         def initialize
/           @mutex = Mutex.new  # mutex for changing channel state
/ 
/           @block_type = :none # block type
/           @block_set = []     # blocked threads/values/refs
/ 
/           @readers = Set.new  # registered readers
/           @writers = Set.new  # registered writers
/ 
/           @open = true        # open/close state
/         end
/ 
/         # ...
/       end
/ 
/ %section
/   %h2 Magritte: Channels
/ 
/   %h3 Channel States (<code>@block_type</code>)
/ 
/   .vs3>
/     %h4 <code>:write</code>
/     = code 'plaintext' do
/       :plain
/         (t,v)
/         ******** -> _(.w._)
/ 
/   .vs3>
/     %h4 <code>:none</code>
/     = code 'plaintext' do
/       :plain
/                 ~~~
/               v(.w.)v
/ 
/   .vs3>
/     %h4 <code>:read</code>
/     = code 'plaintext' do
/       :plain
/                      (t,_)
/         (_.w.)_ <- *******
/ 
/   -#>
/ 
/   .vs3>
/     block set contains<br>
/     %code (thread, value)
/     pairs (<code>Sender</code>)
/ 
/   .vs3>
/ 
/   .vs3>
/     block set contains<br>
/     %code (thread, ref)
/     pairs (<code>Receiver</code>)
/ 
/ 
/ 
/ 
/ %section
/   %h2 Magritte: Channels
/ 
/   %h4 Blocked Writers
/ 
/   .vs>
/     = code 'ruby' do
/       :plain
/         def read
/         # ...
/         case @block_type
/         when :none, :read
/           # ...
/         when :write
/           sender = @block_set.shift
/           @block_set.empty? &&
/             @block_type = :none
/ 
/           sender.wakeup
/           return sender.val
/         end
/ 
/   .vs>
/     = code 'ruby' do
/       :plain
/         def write(val)
/         # ...
/         case @block_type
/         when :none, :write
/           @block_type = :write
/           @block_set <<
/             Sender.new(Thread.current,
/                        val)
/           @mutex.sleep
/         when :read
/           # ...
/         end
/ 
/   -# >
/ 
/ %section
/   %h2 Magritte: Channels
/ 
/   %h4 Blocked Readers
/ 
/   .vs>
/     = code 'ruby' do
/       :plain
/         def read
/         # ...
/         case @block_type
/         when :none, :read
/           @block_type = :read
/           receiver =
/             Receiver.new(Thread.current)
/           @block_set << receiver
/ 
/           @mutex.sleep
/           return receiver.val
/         when :write
/           # ...
/         end
/   -# >
/ 
/   .vs>
/     = code 'ruby' do
/       :plain
/         def write(val)
/         # ...
/         case @block_type
/         when :none, :write
/           # ...
/         when :read
/           receiver = @block_set.shift
/           @block_set.empty? &&
/             @block_type = :none
/ 
/           receiver.val = val
/           receiver.wakeup
/           # ...
/         end
/ 
/ %section
/   %h2 Magritte: Channel Registration
/ 
/   .block
/     %ul
/       %li Register and unregister processes at launch and exit
/       %li
/         When the last process unregisters from either end,
/         %ol
/           %li Set the channel state to closed
/           %li Interrupt all the processes in the block set
/           %li Cause any further reads/writes to interrupt the process
/ 
/       %li
/         Important: Eagerly remove our own thread from the block set
/         so we don't interrupt ourself during shutdown!
/ 
/ %section
/   %h2 Magritte: Channel Registration
/ 
/   = code 'ruby' do
/     :plain
/       class Proc
/         # ...
/         def start
/           # ...
/           @env.each_input { |c| c.add_reader(self) }
/           @env.each_output { |c| c.add_writer(self) }
/           @thread[:magritte_start_mutex].unlock # start running user code!
/           # ...
/         end
/ 
/         # ...
/ 
/         def cleanup!
/           @env.each_input { |c| c.remove_reader(self) }
/           @env.each_output { |c| c.remove_writer(self) }
/         end
/ 
/ %section
/   %h2 Magritte: Channel Registration
/ 
/   = code 'ruby' do
/     :plain
/       def remove_reader(process)
/         action = @mutex.synchronize do
/           next :nop unless @open
/           @block_set.reject! { |b| b.thread == process } if @block_type == :read
/ 
/           @readers.delete(process)
/           next :nop if @readers.size > 0
/ 
/           @open = false
/           :close
/         end
/ 
/         @block_set.each(&:interrupt!) if action == :close
/       end
/  -# >
/%section
/  %h2 Implementation Progress
/  %h3 RPython + MacroPy
/  .block
/    = code 'python' do
/      :plain
/        @functor
/        class Syntax:
/            class list([elements]): pass
/            class paren([statements]): pass
/            class assign(~lhs, ~rhs): pass
/            class bare(value/unicode): pass
/            class dynvar(name/unicode): pass
/            class pipe(~lhs, ~rhs): pass
/            class call(loc/LocRange, ~func, [args]): pass
/            ...
/
/%section
/  %h2 Implementation Progress
/  %h3 In-Progress
/  .block
/    %ul
/      %li Skeleton Tree-based parser
/      %li Bytecode Design
/  %h3 TODO
/  .block
/    %ul
/      %li Bytecode Compiler
/      %li Bytecode Interpreter

%section
  %h2 Questions?

%section
  %h2 Thank You!
