# Random generator that only outputs either 0 or 1
(binary-rand) = (round 0 (rand))

# Generate a sequence of n random bits
(gen-bits ?n) = (produce binary-rand | take %n)

(from-base ?b) = (
  num = 0
  each (?d =>
    %num = (mul %b %num | into add %d)
  )
  put %num
)

# Generate a random number having n bits. Note that the function
# breaks when n < 3 because we want to ensure that the leading and
# trailing bit is set to 1. Of course, nobody should actually call the
# function with n < 3 because that defeats the purpose of the function.
(gen-number ?n) = ((put 1; (gen-bits (add %n -2)); put 1) | from-base 2)

put (gen-number 20)

(miller-rabin-factoring ?num ?r) = (
  eq 0 (mod 2 %num) && miller-rabin-factoring (div 2 %num) (inc %r)
    !! put %r %num
)

put "hey 3"

(miller-rabin-loop ?r ?x ?n) = (
  iter (?x => mod 2 (pow 2 %x) | take (dec %r) | any [eq (dec %n)])
  #gt 0 %iter || fail
  #%x = pow 2 %x
  #eq %x (dec %n) && return
  #miller-rabin-loop (dec %iter) %x %n
)

put "hey 2"

(random-number-in-range ?begin ?end) = (
  mul (sub %begin %end) (rand) | into round 0 | into add %begin
)

(miller-rabin-test ?iter ?num ?r ?d) = (
  range %iter | all (_ =>
    rand_num = (random-number-in-range 2 (sub 2 %num))
    x = (pow %d %rand_num | into mod %num)
    eq %x 1 || eq %x (dec %num)
      || miller-rabin-loop (dec %r) %x %num
  )
)

put "hey 1"

(miller-rabin ?iter ?num) = (
  eq 1 (mod 2 %num) &&
  (r d = (miller-rabin-factoring (dec %num) 0)
  miller-rabin-test %iter %num %r %d)
)

put "hey 0"

(miller-rabin 4 13) && put "Is prime" !! put "Is not prime!"
